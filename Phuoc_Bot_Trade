import os
import json
import threading
import time
from datetime import datetime, timedelta
import MetaTrader5 as mt5
import pandas as pd
import numpy as np
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog

# ----------------------- CÀI ĐẶT MẶC ĐỊNH -----------------------
FILE_TAIKHOAN = "mt5_accounts.json"
SYMBOL_MẶCĐỊNH = "XAUUSD"
RISK_PERCENT = 1.0
REWARD_RATIO = 1.0  # TP = 1xATR
SL_MULTIPLIER_DEFAULT = 2.0  # SL = 2xATR
SLEEP_INTERVAL = 0.1  # ~20 lệnh/phút
MAX_POS_PER_SIDE = 9999
LEVEL_LOOKBACK_BARS = 1000
FRACTAL_STRENGTH = 1
LEVEL_PROXIMITY_ATR = 0.5
SL_CLOSE_THRESHOLD = 0.2  # Chốt lỗ khi giá cách SL < 20% khoảng cách SL
TP_CLOSE_THRESHOLD = 0.1  # Chốt lãi khi giá cách TP < 10% khoảng cách TP
MIN_PROFIT_ATR = 1.0  # Chốt lãi khi lợi nhuận >= 1xATR
TRAILING_STOP_MULTIPLIER = 0.5  # Trailing stop chặt hơn
MAX_LOSS_DURATION = 600  # 10 phút (giây)
HIGHER_TF = mt5.TIMEFRAME_H1
MA_PERIOD = 20
RSI_PERIOD = 14
RSI_OVERBOUGHT = 60  # RSI < 60 cho BUY
RSI_OVERSOLD = 40   # RSI > 40 cho SELL
MAX_CONSECUTIVE_LOSSES = 3
RISK_REDUCTION_FACTOR = 0.5

# ----------------------- LOGGER -----------------------
import logging
LOG_FILE = "bot_xau.log"
logging.basicConfig(level=logging.INFO,
                    format='[%(asctime)s] %(levelname)s: %(message)s',
                    handlers=[logging.FileHandler(LOG_FILE, encoding='utf-8'),
                              logging.StreamHandler()])

def log(msg, level="info"):
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{ts}] {msg}"
    if level == "info":
        logging.info(msg)
    elif level == "warning":
        logging.warning(msg)
    elif level == "error":
        logging.error(msg)

# ----------------------- THREAD LOCK FOR MT5 -----------------------
mt5_lock = threading.Lock()

def safe_mt5_call(func, *args, **kwargs):
    with mt5_lock:
        return func(*args, **kwargs)

# ----------------------- CÁC HÀM CHỈ BÁO -----------------------
def atr_wilder(high, low, close, period=14):
    tr1 = high - low
    tr2 = (high - close.shift(1)).abs()
    tr3 = (low - close.shift(1)).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    return tr.ewm(alpha=1/period, adjust=False).mean()

def find_support_resistance(df, strength=1):
    resistances = []
    supports = []
    for i in range(strength, len(df) - strength):
        is_resistance = all(df['high'][i] > df['high'][i - j] for j in range(1, strength + 1)) and \
                        all(df['high'][i] > df['high'][i + j] for j in range(1, strength + 1))
        if is_resistance:
            resistances.append((df.index[i], df['high'][i]))
        is_support = all(df['low'][i] < df['low'][i - j] for j in range(1, strength + 1)) and \
                     all(df['low'][i] < df['low'][i + j] for j in range(1, strength + 1))
        if is_support:
            supports.append((df.index[i], df['low'][i]))
    resistances = sorted(set([r[1] for r in resistances]), reverse=True)
    supports = sorted(set([s[1] for s in supports]))
    return supports, resistances

def get_higher_tf_trend(symbol, tf=HIGHER_TF, bars=MA_PERIOD+1):
    rates = safe_mt5_call(mt5.copy_rates_from_pos, symbol, tf, 0, bars)
    if rates is None or len(rates) < bars:
        return "neutral"
    df = pd.DataFrame(rates)
    df['ma'] = df['close'].rolling(MA_PERIOD).mean()
    if df['ma'].iloc[-1] > df['ma'].iloc[-2]:
        return "bullish"
    elif df['ma'].iloc[-1] < df['ma'].iloc[-2]:
        return "bearish"
    return "neutral"

def rsi(close, period=RSI_PERIOD):
    delta = close.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# ----------------------- HELPERS MT5 -----------------------
def ensure_symbol(symbol):
    info = safe_mt5_call(mt5.symbol_info, symbol)
    if info is None:
        log(f"[ERROR] Symbol {symbol} không tồn tại", "error")
        return False
    if not info.visible:
        try:
            safe_mt5_call(mt5.symbol_select, symbol, True)
            log(f"[INFO] Đã chọn symbol {symbol} để hiển thị")
        except Exception as e:
            log(f"[ERROR] Không thể chọn symbol {symbol}: {e}", "error")
            return False
    return True

def format_ret(res):
    try:
        return str(res)
    except Exception:
        return repr(res)

import math

def normalize_volume(symbol, volume):
    try:
        info = safe_mt5_call(mt5.symbol_info, symbol)
        if info is None:
            log(f"[ERROR] Không lấy được thông tin symbol {symbol}", "error")
            return float(volume)
        step = getattr(info, 'volume_step', 0.01)
        min_vol = getattr(info, 'volume_min', 0.01)
        max_vol = getattr(info, 'volume_max', 100.0)
        vol = float(volume)
        vol = max(min_vol, min(vol, max_vol))
        steps = math.floor((vol - min_vol) / step + 1e-9)
        normalized = min_vol + steps * step
        decimals = max(0, int(round(-math.log10(step))))
        return float(round(normalized, decimals))
    except Exception as e:
        log(f"[ERROR] normalize_volume: {e}", "error")
        return float(volume)

def safe_order_send(request, retries=3, backoff=1.5):
    last_res = None
    for attempt in range(1, retries + 1):
        try:
            with mt5_lock:
                res = mt5.order_send(request)
        except Exception as e:
            log(f"[ERROR] order_send attempt {attempt}: {e}", "error")
            res = None
        if res is None:
            last_res = res
            time.sleep(backoff * attempt)
            continue
        log(f"[ORDER_SEND] attempt={attempt} retcode={getattr(res,'retcode',None)} order={getattr(res,'order',None)}")
        retcode = getattr(res, 'retcode', None)
        if retcode == getattr(mt5, 'TRADE_RETCODE_DONE', 10009) or retcode == 10009:
            return res
        last_res = res
        time.sleep(backoff * attempt)
    log(f"[ERROR] order_send thất bại sau {retries} lần thử: {format_ret(last_res)}", "error")
    return last_res

def close_position_by_ticket(ticket, volume=None, deviation=20):
    try:
        with mt5_lock:
            pos_list = mt5.positions_get(ticket=ticket)
    except Exception as e:
        log(f"[ERROR] positions_get: {e}", "error")
        return None
    if not pos_list:
        log(f"[WARN] Không tìm thấy vị thế ticket {ticket}", "warning")
        return None
    pos = pos_list[0]
    symbol = pos.symbol
    close_volume = float(volume) if volume is not None else float(pos.volume)
    if close_volume <= 0:
        log(f"[ERROR] Volume đóng lệnh không hợp lệ: {close_volume}", "error")
        return None
    tick = safe_mt5_call(mt5.symbol_info_tick, symbol)
    if tick is None:
        log(f"[ERROR] Không lấy được tick cho symbol {symbol}", "error")
        return None
    if pos.type == mt5.ORDER_TYPE_BUY:
        order_type = mt5.ORDER_TYPE_SELL
        price = tick.bid
    else:
        order_type = mt5.ORDER_TYPE_BUY
        price = tick.ask
    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "position": int(ticket),
        "symbol": symbol,
        "volume": float(close_volume),
        "type": order_type,
        "price": float(price),
        "deviation": int(deviation),
        "magic": int(getattr(pos, 'magic', 0)),
        "comment": "bot_xau_close",
        "type_filling": mt5.ORDER_FILLING_IOC,
    }
    res = safe_order_send(request)
    return res

def modify_sl_tp(ticket, new_sl, new_tp=None):
    try:
        pos_list = safe_mt5_call(mt5.positions_get, ticket=ticket)
        if not pos_list:
            log(f"[WARN] Không tìm thấy vị thế ticket {ticket}", "warning")
            return None
        pos = pos_list[0]
        symbol = pos.symbol
        request = {
            "action": mt5.TRADE_ACTION_SLTP,
            "position": int(ticket),
            "symbol": symbol,
            "sl": float(new_sl),
            "tp": float(new_tp) if new_tp is not None else float(pos.tp),
        }
        res = safe_order_send(request)
        return res
    except Exception as e:
        log(f"[ERROR] modify_sl_tp: {e}", "error")
        return None

# ----------------------- ỨNG DỤNG GUI CHÍNH -----------------------
class BotXAU:
    def __init__(self, root):
        self.root = root
        self.root.title("Bot XAU Scalping (Support/Resistance M1)")
        self.ds_taikhoan = []
        self.symbol = tk.StringVar(value=SYMBOL_MẶCĐỊNH)
        self.risk_pct = tk.DoubleVar(value=RISK_PERCENT)
        self.stop_balance = tk.DoubleVar(value=50.0)
        self.max_positions = tk.IntVar(value=MAX_POS_PER_SIDE)
        self.reward_ratio = tk.DoubleVar(value=REWARD_RATIO)
        self.sl_multiplier = tk.DoubleVar(value=SL_MULTIPLIER_DEFAULT)
        self.running = False
        self.stop_event = threading.Event()
        self.file_accounts = FILE_TAIKHOAN
        self.load_accounts()
        self.build_ui()
        self.log("Ứng dụng sẵn sàng. Scalping XAUUSD: Vào lệnh nhanh tại S/R, chốt lãi sớm, chốt lỗ khi giá phục hồi hoặc xu hướng ngược.")
        self.consecutive_losses = 0
        self.current_risk_pct = RISK_PERCENT

    def build_ui(self):
        frm = ttk.Frame(self.root, padding=8)
        frm.pack(fill=tk.X)
        ttk.Label(frm, text="Symbol:").grid(row=0, column=0, sticky=tk.W)
        ttk.Entry(frm, textvariable=self.symbol, width=12).grid(row=0, column=1, sticky=tk.W)
        ttk.Label(frm, text="Risk %:").grid(row=0, column=2, sticky=tk.W)
        ttk.Entry(frm, textvariable=self.risk_pct, width=8).grid(row=0, column=3, sticky=tk.W)
        ttk.Label(frm, text="Stop Balance ($):").grid(row=0, column=4, sticky=tk.W)
        ttk.Entry(frm, textvariable=self.stop_balance, width=10).grid(row=0, column=5, sticky=tk.W)
        ttk.Label(frm, text="Max positions/side:").grid(row=1, column=0, sticky=tk.W)
        ttk.Entry(frm, textvariable=self.max_positions, width=6).grid(row=1, column=1, sticky=tk.W)
        ttk.Label(frm, text="TP/ATR ratio:").grid(row=1, column=2, sticky=tk.W)
        ttk.Entry(frm, textvariable=self.reward_ratio, width=6).grid(row=1, column=3, sticky=tk.W)
        ttk.Label(frm, text="SL/ATR multiplier:").grid(row=1, column=4, sticky=tk.W)
        ttk.Entry(frm, textvariable=self.sl_multiplier, width=6).grid(row=1, column=5, sticky=tk.W)
        acc_fr = ttk.LabelFrame(self.root, text="Tài khoản MT5", padding=6)
        acc_fr.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(acc_fr, text="Thêm/Lưu tài khoản", command=self.add_account).grid(row=0, column=0)
        ttk.Button(acc_fr, text="Kết nối từ chọn", command=self.connect_selected).grid(row=0, column=1)
        ttk.Button(acc_fr, text="Ngắt kết nối", command=self.disconnect_mt5).grid(row=0, column=2)
        ttk.Button(acc_fr, text="Xoá tài khoản", command=self.delete_account).grid(row=0, column=3)
        self.lst_accounts = tk.Listbox(acc_fr, height=4)
        self.lst_accounts.grid(row=1, column=0, columnspan=4, sticky="we", pady=6)
        self.lst_accounts.bind("<<ListboxSelect>>", self.on_account_select)
        self.refresh_account_listbox()
        ctrl_fr = ttk.Frame(self.root, padding=6)
        ctrl_fr.pack(fill=tk.X)
        self.lbl_balance = ttk.Label(ctrl_fr, text="Balance hiện tại: -")
        self.lbl_balance.pack(side=tk.LEFT, padx=6)
        self.lbl_start_balance = ttk.Label(ctrl_fr, text="Balance khởi động: -")
        self.lbl_start_balance.pack(side=tk.LEFT, padx=6)
        ttk.Button(ctrl_fr, text="Bắt đầu", command=self.start).pack(side=tk.RIGHT, padx=6)
        ttk.Button(ctrl_fr, text="Dừng", command=self.stop).pack(side=tk.RIGHT, padx=6)
        log_fr = ttk.LabelFrame(self.root, text="Nhật ký giao dịch", padding=6)
        log_fr.pack(fill=tk.BOTH, expand=True, padx=8, pady=6)
        self.txt_log = tk.Text(log_fr, height=22, wrap=tk.NONE)
        self.txt_log.pack(fill=tk.BOTH, expand=True)

    def load_accounts(self):
        if not os.path.exists(self.file_accounts):
            self.ds_taikhoan = []
            return
        try:
            with open(self.file_accounts, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.ds_taikhoan = [entry for entry in data if all(k in entry for k in ("login", "password", "server"))]
        except Exception as e:
            self.log(f"[ERROR] Lỗi load accounts: {e}", "error")

    def save_accounts(self):
        try:
            with open(self.file_accounts, "w", encoding="utf-8") as f:
                json.dump(self.ds_taikhoan, f, indent=2, ensure_ascii=False)
        except Exception as e:
            self.log(f"[ERROR] Lỗi lưu accounts: {e}", "error")

    def add_account(self):
        login = simpledialog.askstring("Login", "Nhập số tài khoản (login):", parent=self.root)
        if not login:
            return
        password = simpledialog.askstring("Password", "Nhập mật khẩu:", parent=self.root, show="*")
        if password is None:
            return
        server = simpledialog.askstring("Server", "Nhập server:", parent=self.root)
        if server is None:
            return
        name = simpledialog.askstring("Tên hiển thị", "Tên hiển thị (tùy chọn):", parent=self.root)
        entry = {"login": str(login), "password": password, "server": server, "name": name or str(login)}
        self.ds_taikhoan.append(entry)
        self.save_accounts()
        self.refresh_account_listbox()
        self.log(f"[INFO] Đã thêm tài khoản: {entry['name']}")

    def refresh_account_listbox(self):
        self.lst_accounts.delete(0, tk.END)
        for e in self.ds_taikhoan:
            display = f"{e.get('name', e['login'])} ({e['login']}) @ {e['server']}"
            self.lst_accounts.insert(tk.END, display)

    def delete_account(self):
        sel = self.lst_accounts.curselection()
        if not sel:
            messagebox.showinfo("Xóa", "Chưa chọn tài khoản.")
            return
        idx = sel[0]
        acc = self.ds_taikhoan.pop(idx)
        self.save_accounts()
        self.refresh_account_listbox()
        self.log(f"[INFO] Đã xoá tài khoản {acc.get('name')}")

    def on_account_select(self, event):
        sel = self.lst_accounts.curselection()
        if not sel:
            return
        idx = sel[0]
        acc = self.ds_taikhoan[idx]
        try:
            self.login = int(acc["login"])
        except Exception:
            try:
                self.login = int(str(acc["login"]).strip())
            except Exception:
                self.login = None
        self.password = acc.get("password")
        self.server = acc.get("server")
        self.log(f"[INFO] Chọn tài khoản {acc.get('name', acc.get('login'))} (chưa kết nối)")

    def connect_selected(self):
        if self.login is None or self.password is None or self.server is None:
            messagebox.showwarning("Kết nối", "Chưa chọn tài khoản hợp lệ.")
            return
        try:
            safe_mt5_call(mt5.shutdown)
            ok = safe_mt5_call(mt5.initialize, login=self.login, password=self.password, server=self.server, timeout=5000)
            if not ok:
                err = safe_mt5_call(mt5.last_error)
                self.log(f"[ERROR] Kết nối MT5 thất bại: {err}", "error")
                messagebox.showerror("Kết nối", f"Kết nối thất bại: {err}")
                return
            info = safe_mt5_call(mt5.account_info)
            if info:
                self.log(f"[INFO] Kết nối MT5 thành công. Account: {info.login}, Balance: {info.balance:.2f}")
            else:
                self.log("[WARN] Kết nối MT5 nhưng không lấy được account info.", "warning")
        except Exception as e:
            self.log(f"[ERROR] Lỗi kết nối MT5: {e}", "error")

    def disconnect_mt5(self):
        try:
            safe_mt5_call(mt5.shutdown)
            self.log("[INFO] Ngắt kết nối MT5.")
        except Exception as e:
            self.log(f"[ERROR] Lỗi khi ngắt kết nối: {e}", "error")

    def log(self, msg, level="info"):
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        line = f"[{ts}] {msg}\n"
        print(line, end="")
        try:
            self.txt_log.insert(tk.END, line)
            self.txt_log.see(tk.END)
        except Exception:
            pass
        log(msg, level)

    def start(self):
        if self.running:
            messagebox.showinfo("Bot", "Bot đang chạy.")
            return
        info = safe_mt5_call(mt5.account_info)
        if not info:
            self.log("[ERROR] Chưa kết nối MT5. Vui lòng connect trước.", "error")
            return
        self.running = True
        self.stop_event.clear()
        self.balance_start = float(info.balance)
        self.lbl_start_balance.config(text=f"Balance khởi động: {self.balance_start:.2f}")
        self.log("[INFO] Bắt đầu bot.")
        threading.Thread(target=self.trading_loop, daemon=True).start()
        threading.Thread(target=self.balance_updater, daemon=True).start()
        threading.Thread(target=self.position_manager_loop, daemon=True).start()

    def stop(self):
        if not self.running:
            self.log("[INFO] Bot chưa chạy.")
            return
        self.log("[INFO] Yêu cầu dừng bot ...")
        self.stop_event.set()
        self.running = False

    def balance_updater(self):
        while self.running and not self.stop_event.is_set():
            try:
                info = safe_mt5_call(mt5.account_info)
                if info:
                    self.lbl_balance.config(text=f"Balance hiện tại: {info.balance:.2f}")
            except Exception as e:
                self.log(f"[ERROR] balance_updater: {e}", "error")
            time.sleep(3)

    def get_current_atr(self, symbol):
        rates = safe_mt5_call(mt5.copy_rates_from_pos, symbol, mt5.TIMEFRAME_M1, 0, 15)
        if rates is None:
            return 0
        df = pd.DataFrame(rates)
        atr = atr_wilder(df['high'], df['low'], df['close']).iloc[-1]
        return atr

    def position_manager_loop(self):
        while self.running and not self.stop_event.is_set():
            try:
                symbol = self.symbol.get().strip()
                with mt5_lock:
                    positions = mt5.positions_get(symbol=symbol)
                if not positions:
                    time.sleep(1.0)
                    continue

                trend = get_higher_tf_trend(symbol)
                self.log(f"[MULTI-TF] Xu hướng H1: {trend}")

                atr = self.get_current_atr(symbol)
                if atr <= 0:
                    self.log("[ERROR] ATR không hợp lệ", "error")
                    time.sleep(1)
                    continue

                rates = safe_mt5_call(mt5.copy_rates_from_pos, symbol, mt5.TIMEFRAME_M1, 0, RSI_PERIOD+1)
                if rates is None:
                    continue
                df = pd.DataFrame(rates)
                rsi_val = rsi(df['close']).iloc[-1]

                rates_m1 = safe_mt5_call(mt5.copy_rates_from_pos, symbol, mt5.TIMEFRAME_M1, 0, LEVEL_LOOKBACK_BARS)
                if rates_m1 is None:
                    continue
                df1 = pd.DataFrame(rates_m1)
                df1.set_index('time', inplace=True)
                supports, resistances = find_support_resistance(df1, FRACTAL_STRENGTH)
                current_price = df1['close'].iloc[-1]
                closest_support = max([s for s in supports if s < current_price] or [0], default=None)
                closest_resistance = min([r for r in resistances if r > current_price] or [float('inf')], default=None)

                profitable_positions = []
                losing_positions = []
                for p in positions:
                    ticket = int(p.ticket)
                    price_open = float(p.price_open)
                    tp_price = getattr(p, "tp", None)
                    sl_price = getattr(p, "sl", None)
                    if tp_price is None or sl_price is None or tp_price == 0 or sl_price == 0:
                        continue
                    current_price = safe_mt5_call(mt5.symbol_info_tick, symbol).bid if p.type == mt5.ORDER_TYPE_BUY else safe_mt5_call(mt5.symbol_info_tick, symbol).ask
                    if current_price is None:
                        continue

                    profit = float(p.profit)
                    profit_atr = profit / (atr * p.volume * safe_mt5_call(mt5.symbol_info, symbol).trade_tick_value)
                    time_open = datetime.fromtimestamp(p.time)
                    time_elapsed = (datetime.now() - time_open).total_seconds()

                    if profit > 0:
                        profitable_positions.append((p, current_price, profit_atr))
                    elif profit < 0:
                        losing_positions.append((p, current_price, time_elapsed))

                    # Trailing SL
                    if profit > 0:
                        if p.type == mt5.ORDER_TYPE_BUY:
                            new_sl = current_price - atr * TRAILING_STOP_MULTIPLIER
                            if new_sl > sl_price:
                                self.log(f"[TRAILING] Di chuyển SL cho BUY #{ticket} đến {new_sl:.4f}")
                                modify_res = modify_sl_tp(ticket, new_sl)
                                self.log(f"[MODIFY RESULT] {format_ret(modify_res)}")
                        else:  # SELL
                            new_sl = current_price + atr * TRAILING_STOP_MULTIPLIER
                            if new_sl < sl_price:
                                self.log(f"[TRAILING] Di chuyển SL cho SELL #{ticket} đến {new_sl:.4f}")
                                modify_res = modify_sl_tp(ticket, new_sl)
                                self.log(f"[MODIFY RESULT] {format_ret(modify_res)}")

                    # Chốt lỗ sớm khi gần SL và xu hướng ngược
                    sl_distance_initial = abs(price_open - sl_price)
                    current_to_sl = abs(current_price - sl_price)
                    if p.type == mt5.ORDER_TYPE_BUY:
                        should_close_sl = current_price < price_open and current_to_sl <= sl_distance_initial * SL_CLOSE_THRESHOLD and trend == "bearish"
                    else:  # SELL
                        should_close_sl = current_price > price_open and current_to_sl <= sl_distance_initial * SL_CLOSE_THRESHOLD and trend == "bullish"
                    if should_close_sl:
                        self.log(f"[EARLY CLOSE] Đóng #{ticket} vì giá gần SL và trend ngược")
                        close_res = close_position_by_ticket(ticket)
                        self.log(f"[CLOSE RESULT] {format_ret(close_res)}")
                        if close_res and close_res.retcode == 10009 and profit < 0:
                            self.consecutive_losses += 1
                            if self.consecutive_losses >= MAX_CONSECUTIVE_LOSSES:
                                self.current_risk_pct *= RISK_REDUCTION_FACTOR
                                self.log(f"[RISK MANAGEMENT] Reduced risk to {self.current_risk_pct}% after {self.consecutive_losses} losses")
                        else:
                            self.consecutive_losses = 0
                            self.current_risk_pct = RISK_PERCENT

                    # Chốt lỗ nếu lệnh kéo dài quá lâu
                    if profit < 0 and time_elapsed > MAX_LOSS_DURATION:
                        current_to_open = abs(current_price - price_open)
                        if current_to_open < atr * 0.5:
                            self.log(f"[LOSS CUT] Đóng #{ticket} vì lệnh lỗ quá {MAX_LOSS_DURATION}s và giá gần entry")
                            close_res = close_position_by_ticket(ticket)
                            self.log(f"[CLOSE RESULT] {format_ret(close_res)}")
                            if close_res and close_res.retcode == 10009:
                                self.consecutive_losses += 1
                                if self.consecutive_losses >= MAX_CONSECUTIVE_LOSSES:
                                    self.current_risk_pct *= RISK_REDUCTION_FACTOR
                                    self.log(f"[RISK MANAGEMENT] Reduced risk to {self.current_risk_pct}% after {self.consecutive_losses} losses")

                # Chốt lãi
                for pos, current_price, profit_atr in profitable_positions:
                    ticket = int(pos.ticket)
                    price_open = float(pos.price_open)
                    if (profit_atr >= MIN_PROFIT_ATR) or \
                       (pos.type == mt5.ORDER_TYPE_BUY and closest_resistance is not None and abs(current_price - closest_resistance) < atr * 0.2) or \
                       (pos.type == mt5.ORDER_TYPE_SELL and closest_support is not None and abs(current_price - closest_support) < atr * 0.2) or \
                       (pos.type == mt5.ORDER_TYPE_BUY and rsi_val > RSI_OVERBOUGHT) or \
                       (pos.type == mt5.ORDER_TYPE_SELL and rsi_val < RSI_OVERSOLD):
                        self.log(f"[PROFIT CLOSE] Đóng #{ticket} vì lợi nhuận={profit_atr:.2f}xATR hoặc gần mức S/R hoặc RSI đảo chiều")
                        close_res = close_position_by_ticket(ticket)
                        self.log(f"[CLOSE RESULT] {format_ret(close_res)}")
                        self.consecutive_losses = 0
                        self.current_risk_pct = RISK_PERCENT

                # Chốt lỗ nếu xu hướng H1 ngược mạnh
                ma20 = df1['close'].rolling(MA_PERIOD).mean()
                ma_slope = (ma20.iloc[-1] - ma20.iloc[-2]) / ma20.iloc[-2] if ma20.iloc[-2] != 0 else 0
                for pos, current_price, time_elapsed in losing_positions:
                    ticket = int(pos.ticket)
                    pos_type = pos.type
                    if (trend == "bullish" and pos_type == mt5.ORDER_TYPE_SELL and abs(ma_slope) > 0.005) or \
                       (trend == "bearish" and pos_type == mt5.ORDER_TYPE_BUY and abs(ma_slope) > 0.005):
                        self.log(f"[MULTI-TF CLOSE] Đóng #{ticket} vì xu hướng H1 ngược mạnh (slope={ma_slope:.4f})")
                        close_res = close_position_by_ticket(ticket)
                        self.log(f"[CLOSE RESULT] {format_ret(close_res)}")
                        if close_res and close_res.retcode == 10009:
                            self.consecutive_losses += 1
                            if self.consecutive_losses >= MAX_CONSECUTIVE_LOSSES:
                                self.current_risk_pct *= RISK_REDUCTION_FACTOR
                                self.log(f"[RISK MANAGEMENT] Reduced risk to {self.current_risk_pct}% after {self.consecutive_losses} losses")

                time.sleep(1.0)
            except Exception as e:
                self.log(f"[ERROR] position_manager_loop: {e}", "error")
                time.sleep(1)

    def trading_loop(self):
        symbol = self.symbol.get().strip()
        risk_pct = float(self.risk_pct.get())
        stop_bal = float(self.stop_balance.get())
        max_pos = int(self.max_positions.get())
        reward_ratio = float(self.reward_ratio.get())
        sl_mult = float(self.sl_multiplier.get())

        self.log(f"[TRADING LOOP] Khởi động với symbol={symbol}, risk={risk_pct}%, max_pos={max_pos}, reward_ratio={reward_ratio}, sl_mult={sl_mult}")

        if not ensure_symbol(symbol):
            self.log(f"[ERROR] Symbol không tồn tại hoặc không hiển thị: {symbol}", "error")
            self.running = False
            return

        consecutive_error = 0
        magic = 20250901
        last_data_time = None

        while self.running and not self.stop_event.is_set():
            try:
                terminal_info = safe_mt5_call(mt5.terminal_info)
                if not terminal_info or not terminal_info.trade_allowed:
                    self.log("[ERROR] AutoTrading bị tắt trong MT5.", "error")
                    time.sleep(5)
                    continue

                acc = safe_mt5_call(mt5.account_info)
                if not acc:
                    self.log("[WARN] Không lấy được thông tin tài khoản - thử reconnect.", "warning")
                    time.sleep(1)
                    continue

                if acc.balance <= stop_bal:
                    self.log(f"[SAFE] Balance {acc.balance:.2f} ≤ ngưỡng {stop_bal:.2f}. Dừng bot.", "warning")
                    self.stop_event.set()
                    self.running = False
                    break

                rates_m1 = safe_mt5_call(mt5.copy_rates_from_pos, symbol, mt5.TIMEFRAME_M1, 0, LEVEL_LOOKBACK_BARS)
                if rates_m1 is None or len(rates_m1) < LEVEL_LOOKBACK_BARS:
                    self.log(f"[WARN] Dữ liệu M1 không đủ, chờ {SLEEP_INTERVAL}s.", "warning")
                    time.sleep(SLEEP_INTERVAL)
                    continue

                tick = safe_mt5_call(mt5.symbol_info_tick, symbol)
                if tick is None or tick.ask == 0 or tick.bid == 0:
                    self.log("[WARN] Thị trường không hoạt động hoặc không lấy được tick.", "warning")
                    time.sleep(SLEEP_INTERVAL)
                    continue

                df1 = pd.DataFrame(rates_m1)
                df1['time'] = pd.to_datetime(df1['time'], unit='s')
                df1.set_index('time', inplace=True)
                df1[['open','high','low','close']] = df1[['open','high','low','close']].astype(float)
                df1['atr14'] = atr_wilder(df1['high'], df1['low'], df1['close'], 14)
                atr_val = float(df1['atr14'].iloc[-1]) if not df1['atr14'].isna().iloc[-1] else 0.0
                df1['rsi'] = rsi(df1['close'])
                rsi_val = df1['rsi'].iloc[-1]
                self.log(f"[ANALYSIS] Close={df1['close'].iloc[-1]:.3f}, ATR14={atr_val:.4f}, RSI={rsi_val:.2f}")

                current_data_time = df1.index[-1]
                if last_data_time == current_data_time:
                    time.sleep(SLEEP_INTERVAL)
                    continue
                last_data_time = current_data_time

                supports, resistances = find_support_resistance(df1, FRACTAL_STRENGTH)
                current_price = df1['close'].iloc[-1]
                closest_support = max([s for s in supports if s < current_price] or [0], default=None)
                closest_resistance = min([r for r in resistances if r > current_price] or [float('inf')], default=None)

                trend = get_higher_tf_trend(symbol)
                self.log(f"[MULTI-TF ENTRY] Xu hướng H1: {trend}")

                buy_signal = False
                sell_signal = False
                reasons_buy = []
                reasons_sell = []

                if closest_support is not None and abs(current_price - closest_support) <= atr_val * LEVEL_PROXIMITY_ATR and (trend == "bullish" or trend == "neutral") and rsi_val < RSI_OVERBOUGHT:
                    buy_signal = True
                    reasons_buy.append(f"Gần support {closest_support:.2f}, xu hướng {trend}, RSI={rsi_val:.2f}")
                if closest_resistance is not None and abs(current_price - closest_resistance) <= atr_val * LEVEL_PROXIMITY_ATR and (trend == "bearish" or trend == "neutral") and rsi_val > RSI_OVERSOLD:
                    sell_signal = True
                    reasons_sell.append(f"Gần resistance {closest_resistance:.2f}, xu hướng {trend}, RSI={rsi_val:.2f}")

                if not buy_signal and not sell_signal:
                    self.log("[INFO] Không gần mức support/resistance hoặc RSI/xu hướng không phù hợp, chờ dữ liệu mới.")
                    time.sleep(SLEEP_INTERVAL)
                    continue

                with mt5_lock:
                    positions = mt5.positions_get(symbol=symbol)
                buy_count = 0
                sell_count = 0
                if positions:
                    for p in positions:
                        try:
                            if p.type == mt5.ORDER_TYPE_BUY:
                                buy_count += 1
                            elif p.type == mt5.ORDER_TYPE_SELL:
                                sell_count += 1
                        except Exception:
                            pass
                self.log(f"[INFO] Vị thế hiện tại: Buy={buy_count}, Sell={sell_count}")

                current_risk_pct = self.current_risk_pct

                if buy_signal and buy_count < max_pos:
                    tick = safe_mt5_call(mt5.symbol_info_tick, symbol)
                    if tick is None:
                        self.log("[ERROR] Không lấy được tick để đặt lệnh.", "error")
                    else:
                        entry_price = tick.ask
                        sl = entry_price - atr_val * sl_mult
                        tp = entry_price + atr_val * reward_ratio
                        if atr_val <= 0:
                            self.log("[ERROR] ATR không hợp lệ, skip đặt lệnh.", "error")
                        else:
                            spread = tick.ask - tick.bid
                            if spread > atr_val * 0.5:
                                self.log(f"[SKIP] Spread quá lớn: {spread:.5f} > ATR*0.5 ({atr_val*0.5:.5f})")
                            else:
                                balance = acc.balance
                                risk_amount = balance * (current_risk_pct / 100)
                                sl_distance = abs(entry_price - sl)
                                info = safe_mt5_call(mt5.symbol_info, symbol)
                                point = info.point
                                tick_value = info.trade_tick_value
                                sl_points = sl_distance / point
                                lot = risk_amount / (sl_points * tick_value)
                                vol = normalize_volume(symbol, lot)
                                if vol < info.volume_min:
                                    self.log(f"[SKIP] Lot tính {vol:.2f} < min {info.volume_min}, skip.")
                                    continue
                                req = {
                                    "action": mt5.TRADE_ACTION_DEAL,
                                    "symbol": symbol,
                                    "volume": float(vol),
                                    "type": mt5.ORDER_TYPE_BUY,
                                    "price": float(entry_price),
                                    "deviation": 20,
                                    "magic": int(magic),
                                    "comment": "bot_xau_scalper",
                                    "type_filling": mt5.ORDER_FILLING_IOC,
                                    "sl": float(sl),
                                    "tp": float(tp)
                                }
                                self.log(f"[ENTRY] MUA vì: {', '.join(reasons_buy)}  entry={entry_price:.4f}  SL={sl:.4f}  TP={tp:.4f}  ATR={atr_val:.4f}  Lot={vol:.2f} Risk={current_risk_pct}%")
                                res = safe_order_send(req)
                                self.log(f"[ORDER RESULT] {format_ret(res)}")

                if sell_signal and sell_count < max_pos:
                    tick = safe_mt5_call(mt5.symbol_info_tick, symbol)
                    if tick is None:
                        self.log("[ERROR] Không lấy được tick để đặt lệnh.", "error")
                    else:
                        entry_price = tick.bid
                        sl = entry_price + atr_val * sl_mult
                        tp = entry_price - atr_val * reward_ratio
                        if atr_val <= 0:
                            self.log("[ERROR] ATR không hợp lệ, skip đặt lệnh.", "error")
                        else:
                            spread = tick.ask - tick.bid
                            if spread > atr_val * 0.5:
                                self.log(f"[SKIP] Spread quá lớn: {spread:.5f} > ATR*0.5 ({atr_val*0.5:.5f})")
                            else:
                                balance = acc.balance
                                risk_amount = balance * (current_risk_pct / 100)
                                sl_distance = abs(entry_price - sl)
                                info = safe_mt5_call(mt5.symbol_info, symbol)
                                point = info.point
                                tick_value = info.trade_tick_value
                                sl_points = sl_distance / point
                                lot = risk_amount / (sl_points * tick_value)
                                vol = normalize_volume(symbol, lot)
                                if vol < info.volume_min:
                                    self.log(f"[SKIP] Lot tính {vol:.2f} < min {info.volume_min}, skip.")
                                    continue
                                req = {
                                    "action": mt5.TRADE_ACTION_DEAL,
                                    "symbol": symbol,
                                    "volume": float(vol),
                                    "type": mt5.ORDER_TYPE_SELL,
                                    "price": float(entry_price),
                                    "deviation": 20,
                                    "magic": int(magic),
                                    "comment": "bot_xau_scalper",
                                    "type_filling": mt5.ORDER_FILLING_IOC,
                                    "sl": float(sl),
                                    "tp": float(tp)
                                }
                                self.log(f"[ENTRY] BÁN vì: {', '.join(reasons_sell)}  entry={entry_price:.4f}  SL={sl:.4f}  TP={tp:.4f}  ATR={atr_val:.4f}  Lot={vol:.2f} Risk={current_risk_pct}%")
                                res = safe_order_send(req)
                                self.log(f"[ORDER RESULT] {format_ret(res)}")

                consecutive_error = 0
                time.sleep(SLEEP_INTERVAL)

            except Exception as e:
                consecutive_error += 1
                self.log(f"[ERROR] Vòng lặp chính: {e} (count={consecutive_error})", "error")
                time.sleep(1)
                if consecutive_error > 8:
                    self.log("[WARN] Nhiều lỗi, pause 5s.", "warning")
                    time.sleep(5)
                    consecutive_error = 0

        self.log("[INFO] Trading loop kết thúc.")
        self.running = False

def main():
    root = tk.Tk()
    app = BotXAU(root)
    root.geometry("980x700")
    root.mainloop()

if __name__ == "__main__":
    main()
